# TANCHIKI_KILL 

## DEVDOC: 
Документация:
	Класс Tank – клаас, отвечающий за танки.
1.	 __init__: Начнем с конструктора. Он инициализирует различные параметры танка, такие как его тип, начальные координаты, направление, уровень и прочее. В этом методе также задаются параметры, отвечающие за движение, выстрелы, состояние здоровья и другие характеристики танка. Также происходит загрузка изображений для анимаций.
2.	update: Этот метод обновляет анимацию танка и проверяет, жив ли он.
3.	move: Метод отвечает за движение танка в зависимости от нажатых клавиш. Тут также обрабатываются столкновения с другими танками и препятствиями.
4.	AI: Если танк принадлежит компьютеру, этот метод отвечает за "искусственный интеллект", который управляет его действиями.
5.	shoot_rocket: Метод для стрельбы (если это игрок) или метод enemy_shoot (если это противник).
6.	 shiled_animation: Этот метод управляет анимацией щита танка.
7.	timer_cooldown: Если активен таймер тайм-аута, этот метод управляет отображением соответствующей анимации.
8.	update_animation: Обновляет текущую анимацию танка в зависимости от его действий.
9.	update_action: Обновляет текущее действие танка (например, движение вверх/вниз/лево/право) и связанную с ним анимацию.
10.	tank_born: Управляет анимацией возрождения танка.
11.	check_alive: Проверяет, жив ли танк, и управляет анимацией взрыва (если он умер).
12.	 draw и draw_blast: Отвечают за отображение танка и анимации взрыва на экране.
	Класс Rocket – класс, отвечающий за пули.
В конструкторе принимает: ссылку на объект типа  Rocket, координаты  х и у, направление пули , его характеристику , а также мощность урона.
             Класс Rocket представляет собой объект пули в игре. Здесь содержатся атрибуты и методы для управления полетом и взаимодействием ракеты с игровым миром.
1.	В методе __init__  инициализируются различные атрибуты вашего объекта rocket, такие как update_time, tile_remove, frame_index_blast, direction, angle и изображения rocket_boom. Загружаете набор изображений для анимации взрыва ракеты из каталога, а затем устанавливается начальное положение и угол наклона в зависимости от направления полета ракеты.
2.	 При обновлении координат пули (update) происходит наращивание x или y в зависимости от направления. После этого происходит проверка на столкновение с областью экрана и обработка коллизий с препятствиями в игровом мире. В случае столкновения с различными типами блоков происходит модификация игрового мира. В  методе обновления,  обновляется изображение пули для анимации взрыва.  Поворачивается изображение в зависимости от угла наклона текущего кадра. Затем  проверяется, прошло ли достаточно времени с момента последнего обновления, чтобы перейти к следующему кадру анимации. Если это так, мы обновляем индекс текущего кадра. Кроме того, мы управляете удалением фрагментов по завершении цикла анимации и в конечном итоге уничтожаете пулю.	
	
	Класс Rocket_blast — класс, отвечающий за анимацию взрыва. Здесь определены методы и атрибуты для управления анимацией взрыва, а также хранения изображений и их последовательного показа для создания визуального эффекта взрыва. В конструкторе принимает: ссылку на объект типа Rocket_blast, координаты x и y.
1.	В конструкторе реализуется инициализация переменных для управления анимацией, происходит загрузка изображений взрыв и  установка изображения и его координат.
2.	При вызове метода update происходит обновление изображения в соответствии с текущим кадром анимации. После этого проверяется, прошло ли достаточное время для перехода к следующему кадру. Если анимация завершена, объект уничтожается.
3.	Этот класс предоставляет удобный способ добавления визуального эффекта взрыва в игру, а также управления последовательным отображением изображений для создания анимации
	
	Класс Wall_blast – класс, отвечающий за эффект взрыва, который происходит при столкновении пули  с стеной в игре. Этот класс содержит методы и атрибуты для управления анимацией взрыва, обработки последствий столкновения и обновления игровой сцены .В конструкторе принимает: ссылку на объект типа Wall_blast, координаты x и y, направление  а также список для хранения разрушенных блоков.
1.	В конструкторе реализуется инициализация переменных, определяется угла и поворот изображения для анимации взрыва и происходит загрузка изображений взрыва и установка изображения и его координат.
2.	При вызове метода update происходит обновление изображения в соответствии с текущим кадром анимации. Затем проверяется, прошло ли достаточное время для перехода к следующему кадру. Если анимация завершена, происходит удаление разрушенных блоков и уничтожение объекта взрыва.
3.	Распишем роль переменной tile_remove играет роль буфера или списка для хранения информации о разрушенных блоках в игровом мире, а также обеспечивает более гладкое и контролируемое управление процессом их удаления из игровой сцены.

	Класс Power_up – отвечает за повышение уровня тайнков, назовем их power_up-ами.
Этот класс управляет созданием, анимацией, удалением и воздействием power-up'ов на игровом поле.
1.	Инициализация: В этом методе происходит инициализация различных переменных, загрузка изображений для power-up'ов, и установка их положения на игровом поле. Так же происходит генерация местоположения: Power-up случайным образом появляется внутри игрового поля. Распишем поподробнее некоторые переменные:
	– self.data - содержит данные о бонусе или усилении (например, его название, эффект и т.д.).
 	– self.spawn_location - координаты, на которых будет появляться бонус.
– self.run - флаг, определяющий, активен ли бонус.
 – self.show_image - флаг, показывающий, отображается ли изображение бонуса. 
 – self.update_time - время последнего обновления бонуса.
 – self.remove_time - время, через которое бонус будет удален.
 – self.animation_count - счетчик анимации бонуса (используется для определения, на какой стадии анимации находится бонус).
 – self.index - индекс текущей анимации.
 – self.powerUP - массив изображений, составляющих анимацию бонуса.
 – self.powerUP_index - текущий индекс изображения в массиве powerUP.
	2. Метод Blink.  Этот метод управляет анимацией мигания power-up'ов, что делает их более заметными или менее заметными для игроков. Он также управляет временным изменением видимости power-up'ов.
	3. Метод power_power_up. Этот метод удаляет power-up после определенного времени через 30 секунд после его появления на игровом поле.
	4. Метод Update. Этот метод обновляет положение power-up'ов на игровом поле.
Также происходит обнаружение столкновений, то есть определяет, поймал ли персонаж (character) какой-либо из power-up'ов, и, если поймал, запускает звуковой эффект.


	
	Класс World  представляет игровой мир в игре и содержит методы для обновления и отображения карты, включая эффекты воды, эффект взрыва орла, восстановление защитных стен орла и отрисовку элементов мира. Методы класса World управляют отображением и обновлением игрового мира, включая анимацию, визуальные эффекты и отображение элементов карты.
1.	Метод init  принимает ссылку на объект метода World и data - представляет данные, описывающие игровой мир. Эта переменная принимает информацию, такую как параметры игрового уровня, типы и расположения элементов, и другие свойства, необходимые для инициализации игрового мира. После загрузки изображений происходит их масштабирование до соответствующего размера, что позволяет корректно отображать их в игровом мире.
2.	Метод water_effect обновляет анимацию воды на карте. Проверяется прошедшее время и обновляется индекс текущего изображения воды, создавая эффект анимации.
3.	Метод eagle_blast_effect обновляет визуальный эффект взрыва орла. Метод обновляет изображение взрыва и его координаты для создания эффекта взрыва орла.
4.	Метод restore_ewall восстанавливает защитные стены орла после прошествия определенного времени. Отображение стен: В зависимости от прошедшего времени и параметров, защитные стены орла восстанавливаются или меняют свой вид.
5.	Метод draw отображает игровой мир на экране. Отображение элементов игрового мира: Этот метод отображает различные элементы игрового мира, включая стены, воду и другие детали изображения.
6.	Метод draw_grass отображает элементы травы на карте. Метод обеспечивает отрисовку элементов травы на карте игрового мира.


	Класс Details представляет из себя совокупность функций, которые выполняют выполняют конкретные функции для отображения информации на экране игры, такие как количество врагов, количество жизней игроков, текущий уровень и счет. Кратко опише что делаю данные функции
1.	Метод init инициализирует объект класса Details, устанавливая начальные значения переменных и загружая изображения. Инициализирует следующие переменные Инициализированные переменные:
  - green, blue, maroon, navy, silver, yellow, red: Цветовые константы.
  - font: Объект шрифта для текстовых элементов интерфейса.
  - score_font: Объект шрифта для отображения счета игры.
  - scoreT_font: Объект шрифта для отображения общего счета.
  - update_time, update_time1, count: Переменные для хранения времени и счетчика.
  - high_sc, high_no, high_no1, no_image, no_lst, pl_image_lst, pl_image, score_img, score_txt_img, score_time, score_time_add, total1, total2, total3, total4, total1_count, total2_count, total3_count, total4_count, width_add, width_add1, height_addT: Различные переменные, списки и изображения, используемые для отображения игровых элементов и интерфейса.
2.	Метод enemy_count. Отображает количество врагов на экране за вычетом значения enemy_counter.
3.	Методы player1_lives(), player2_lives(): Отображают количество жизней соответствующего игрока на экране.
4.	Метод current_level(): Отображает текущий уровень игры на экране.
5.	Методы p1_score(score), p2_score(score): Отображают отдельный счет и общий счет для игроков 1 и 2 соответственно. Вычисляют общий счет на основе количества сбитых объектов каждого типа.
6.	Метод high_score(): Отображает анимацию высоких счетов и обновляет информацию о счете в режиме реального времени. Выполняет различные операции, такие как управление временем, анимация чисел и изображений, а также отображение общего счета и выявление максимального счета.




	Класс Game Over представляет экран "Game Over" в игре.
1.	Инициализируется экземпляр класса с помощью метода init, в котором задаются следующие атрибуты:
go_img: изображение экрана "Game Over", загруженное из файла go.png по указанному пути.
speed: скорость изменения изображения.
fade_fonder: счетчик изменения яркости изображения.
update_time: время последнего обновления изображения.
finish: флаг окончания отображения экрана "Game Over".
 
      2. Метод display отображает экран "Game Over".
•	Если fade_counter равен 2, проигрывается звуковой эффект "gameover".
•	Если fade_counter меньше или равен 240, изображение go_img масштабируется до размеров 300 х 150 пикселей и отображается на экране. Позиция изображения изменяется по вертикали с учетом значения fade_counter. Каждые 15 миллисекунд счетчик fade_counter увеличивается на 2.
•	Если fade_counter больше 240, изображение go_img масштабируется до размеров 300 х 150 пикселей и отображается на экране. Позиция изображения изменяется по вертикали с учетом значения fade_counter. Флаг finish устанавливается в значение True.
world_create()
- Эта функция создает начальную конфигурацию мира для игры. Здесь мы видим использование двумерного списка world_data для представления различных объектов и элементов, таких как стены, враги и игроки.

Описание цикла в конце кода:
- В этой части кода происходит инициализация различных переменных и игровых объектов, таких как clockobject, различные изображения, группы спрайтов (sprite groups) и другие игровые элементы.
  - Основной цикл игры, который обрабатывает игровую логику в зависимости от текущего состояния игры. Каждая итерация этого цикла обновляет игровой экран, обрабатывает ввод от игроков и отслеживает игровые события.
- В этой части кода происходит обработка событий, таких как нажатия клавиш, что позволяет игрокам перемещать персонажей, стрелять, выбирать танки и другие действия.
- Здесь содержатся блоки кода, отвечающие за различные аспекты игровой логики, такие как обновление позиций персонажей, врагов, стрельба, эффекты, механика коллизий и другие игровые механики.
- Этот код обновляет визуальные элементы игры, включая рендеринг изображений, взаимодействие с пользователем и обновление игрового интерфейса.

